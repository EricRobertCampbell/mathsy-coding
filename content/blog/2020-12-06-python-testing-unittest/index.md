---
title: Simple Python Unit Testing with unittest
date: 2020-12-06
description: A quick introduction to Python testing with unittest
---

This week, I've been doing a lot of development using our Django backend. As a result, I've also been writing a lot of unit tests. I find that writing code and the tests for the code concurrently help me to clarify my thinking, writ e less buggy code, and have more confidence that the code that I wrote actually does what I expect!

## Setting Up Tests and Making Assertions

I've been using the excellent Python `unittest` module to write most of my tests. This module comes as part of Python and does what I need it to do. The documentation is up-to-date, fairly easy to understand, and perhaps as importantly, there is a large stockpile of answered questions about it on StackOverflow!

The process of setting up tests and running them is fairly straightforward - you just create a regular Python file whose name starts with `test_` and write your tests in there! Each test suite (group of tests covering a particular aspect of your code) is a subclass of the `unittest.TestCase` class, the individual test cases (tests of one individual part of the suite) are methods of the class that you write. Within each test, you will create assertions about the behaviour of your system.

Generally, a test file will look something like the following:

```python
import unittest

class TestSomething(unittest.TestCase):
	def test_one_aspect(self):
		self.assertEqual(one thing, another thing, "message if there is a failure")
```

In order to run this test, you would type something like the following in your terminal:

```bash
python -m unittest test_something_i_care_about.py
```


## An Example - Testing a Squaring Function
Let's walk through the process in a little more detail. Imagine that we are writing a function to square a number. For functions like this, I like to write the tests first to help myself think though all of the behaviours that I want. In many cases, this involves both positive behaviours that I do want (properly squaring numbers) and negative behaviours that I want to avoid (failing silently on improper inputs). Let's start with a very simple test suite, consisting of nailing down the nailing down the core behaviour of the function:

1. It should square numbers

The actual function will live in `square.py`:

`embed:v1/square.py`

The test file for that would look as follows:

`embed:v1/test_square.py`

To run this, navigate to the folder containing both of these in your terminal, and run the test file:
 
 `embed:v1/results.txt`

From that, we can see that one test was run successfully (the single full stop). If there were an error, then it would display an `E` instead. 

The heart of the tests that we write are the assertions. The `unittest` module comes with a large variety of assertions, all access through the `self` variable. An exhaustive list can be found at [the official docs](https://docs.python-guide.org/writing/tests/).

While this run was interesting, it doesn't give me much confidence in my function. For one, I only tested a single number. For another, I haven't tested any of the error paths - the things that should happen if the input is not what I expect. For these, let's take a moment an iron out the full behaviour of the function:

1. It should square numbers
	1. It should square positive and negative integers, as well as 0
	2. It should square decimals (positive and negative)
2. It should not square non-numbers
	1. It should raise a `TypeError` on receiving an argument that is not a number

Let's see what the test file for the above conditions looks like.

`embed:v2/test_square.py`

A few things to note:
- I am including messages on my assertions this time. Although the error messages generated by `unittest` are gnerally pretty good, when debugging and testing I tend to err on the side of provind more information and context whenever possible. These messages can also aid in understanding what the test is supposed to be testing in the first place!
- Notice that to test whether an exception is thrown, you need to use the syntax
```python
with self.assertRaises(Exception I am expecting):
	f(the call that should raise the exception)
```
As with all error catching, you want to be as specific as possible with the error type you are expecting.

When you run the test, here is the result:

`embed:v2/results.txt`

Excellent! It looks like our function behaves exactly the way that we want.


## Setup and Teardown


## Sources

- [Official Documentation](https://docs.python.org/3/library/unittest.html)
- [Real Python - Getting Started with Testing in Python](https://realpython.com/python-testing/)
- [Hitchhiker's Guide to Python](https://docs.python-guide.org/writing/tests/)
